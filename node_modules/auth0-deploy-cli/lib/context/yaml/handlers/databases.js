"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const utils_1 = require("../../../utils");
const logger_1 = __importDefault(require("../../../logger"));
function parse(context) {
    return __awaiter(this, void 0, void 0, function* () {
        // Load the script file for custom db
        const { databases } = context.assets;
        if (!databases)
            return { databases: null };
        return {
            databases: [
                ...databases.map((database) => (Object.assign(Object.assign({}, database), { options: Object.assign(Object.assign({}, database.options), (database.options.customScripts && {
                        customScripts: Object.entries(database.options.customScripts).reduce((scripts, [name, script]) => (Object.assign(Object.assign({}, scripts), { [name]: context.loadFile(script) })), {}),
                    })) }))),
            ],
        };
    });
}
function dump(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const { databases, clients } = context.assets;
        if (!databases)
            return { databases: null };
        const sortCustomScripts = ([name1], [name2]) => {
            if (name1 === name2)
                return 0;
            return name1 > name2 ? 1 : -1;
        };
        return {
            databases: [
                ...databases.map((database) => (Object.assign(Object.assign(Object.assign({}, database), (database.enabled_clients && {
                    enabled_clients: (0, utils_1.mapClientID2NameSorted)(database.enabled_clients, clients || []),
                })), { options: Object.assign(Object.assign({}, database.options), (database.options.customScripts && {
                        customScripts: Object.entries(database.options.customScripts)
                            //@ts-ignore because we'll fix this in subsequent PR
                            .sort(sortCustomScripts)
                            .reduce((scripts, [name, script]) => {
                            // Create Database folder
                            const dbName = (0, utils_1.sanitize)(database.name);
                            const dbFolder = path_1.default.join(context.basePath, 'databases', (0, utils_1.sanitize)(dbName));
                            fs_extra_1.default.ensureDirSync(dbFolder);
                            // Dump custom script to file
                            const scriptName = (0, utils_1.sanitize)(name);
                            const scriptFile = path_1.default.join(dbFolder, `${scriptName}.js`);
                            logger_1.default.info(`Writing ${scriptFile}`);
                            //@ts-ignore because we'll fix this in subsequent PR
                            fs_extra_1.default.writeFileSync(scriptFile, script);
                            scripts[name] = `./databases/${dbName}/${scriptName}.js`;
                            return scripts;
                        }, {}),
                    })) }))),
            ],
        };
    });
}
const databasesHandler = {
    parse,
    dump,
};
exports.default = databasesHandler;
//# sourceMappingURL=databases.js.map