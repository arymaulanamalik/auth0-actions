"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterOnlyIncludedResourceTypes = exports.setupContext = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const auth0_1 = require("auth0");
const yaml_1 = __importDefault(require("./yaml"));
const directory_1 = __importDefault(require("./directory"));
const utils_1 = require("../utils");
const logger_1 = __importDefault(require("../logger"));
const { version: packageVersion } = require('../../package.json');
const nonPrimitiveProps = [
    // List of properties that are arrays or objects. This list
    // enables decoding of string env variables for these configurations.
    'AUTH0_KEYWORD_REPLACE_MAPPINGS',
    'AUTH0_EXCLUDED_RULES',
    'AUTH0_EXCLUDED_CLIENTS',
    'AUTH0_EXCLUDED_DATABASES',
    'AUTH0_EXCLUDED_CONNECTIONS',
    'AUTH0_EXCLUDED_RESOURCE_SERVERS',
    'AUTH0_EXCLUDED_DEFAULTS',
    'AUTH0_EXCLUDED',
    'AUTH0_INCLUDED_ONLY',
    'EXCLUDED_PROPS',
    'INCLUDED_PROPS',
];
const setupContext = (config, command) => __awaiter(void 0, void 0, void 0, function* () {
    const missingParams = [];
    if (!config.AUTH0_DOMAIN)
        missingParams.push('AUTH0_DOMAIN');
    if (!config.AUTH0_ACCESS_TOKEN) {
        if (!config.AUTH0_CLIENT_ID)
            missingParams.push('AUTH0_CLIENT_ID');
        if (!config.AUTH0_CLIENT_SECRET && !config.AUTH0_CLIENT_SIGNING_KEY_PATH)
            missingParams.push('AUTH0_CLIENT_SECRET or AUTH0_CLIENT_SIGNING_KEY_PATH or AUTH0_ACCESS_TOKEN');
    }
    if (missingParams.length > 0) {
        throw new Error(`The following parameters were missing. Please add them to your config.json or as an environment variable. ${JSON.stringify(missingParams)}`);
    }
    ((config) => {
        if (config.AUTH0_INCLUDED_ONLY === undefined)
            return;
        if (config.AUTH0_INCLUDED_ONLY.length === 0) {
            throw new Error('Need to define at least one resource type in AUTH0_INCLUDED_ONLY configuration. See: https://github.com/auth0/auth0-deploy-cli/blob/master/docs/configuring-the-deploy-cli.md#auth0_included_only');
        }
        const hasExcludedResources = config.AUTH0_EXCLUDED !== undefined && config.AUTH0_EXCLUDED.length > 0;
        const hasIncludedResources = config.AUTH0_INCLUDED_ONLY.length > 0;
        if (hasExcludedResources && hasIncludedResources) {
            throw new Error('Both AUTH0_EXCLUDED and AUTH0_INCLUDED_ONLY configuration values are defined, only one can be configured at a time. See: https://github.com/auth0/auth0-deploy-cli/blob/master/docs/excluding-from-management.md');
        }
    })(config);
    ((config) => {
        if (command === 'import')
            return;
        const shouldPreserveKeywords = 
        //@ts-ignore because the string=>boolean conversion may not have happened if passed-in as env var
        config.AUTH0_PRESERVE_KEYWORDS === 'true' || config.AUTH0_PRESERVE_KEYWORDS === true;
        if (!shouldPreserveKeywords)
            return;
        const isKeywordMappingsEmpty = config.AUTH0_KEYWORD_REPLACE_MAPPINGS === undefined ||
            Object.keys(config.AUTH0_KEYWORD_REPLACE_MAPPINGS).length === 0;
        if (isKeywordMappingsEmpty) {
            throw new Error('Attempting to preserve keywords without defining keyword mappings. Doing so could result in unintentional overwriting of resource configurations. Either define keyword mappings via AUTH0_KEYWORD_REPLACE_MAPPINGS or disable AUTH0_PRESERVE_KEYWORDS.');
        }
        const doLocalFilesExist = (() => {
            if (!(0, fs_1.existsSync)(config.AUTH0_INPUT_FILE))
                return false;
            const isDirectory = (0, fs_1.lstatSync)(config.AUTH0_INPUT_FILE).isDirectory();
            if (isDirectory) {
                return (0, fs_1.readdirSync)(config.AUTH0_INPUT_FILE).length > 0;
            }
            return (0, fs_1.existsSync)(config.AUTH0_INPUT_FILE);
        })();
        if (!doLocalFilesExist) {
            throw new Error('Attempting to preserve keywords for local resource configuration files that do not exist. Ensure that there are resource files in the output directory or disable AUTH0_PRESERVE_KEYWORDS.');
        }
    })(config);
    ((config) => {
        // Detect and warn on usage of deprecated exclusion params. See: https://github.com/auth0/auth0-deploy-cli/issues/451#user-content-deprecated-exclusion-props
        const deprecatedExclusionParams = [
            'AUTH0_EXCLUDED_RULES',
            'AUTH0_EXCLUDED_CLIENTS',
            'AUTH0_EXCLUDED_DATABASES',
            'AUTH0_EXCLUDED_CONNECTIONS',
            'AUTH0_EXCLUDED_RESOURCE_SERVERS',
            'AUTH0_EXCLUDED_DEFAULTS',
        ];
        const usedDeprecatedParams = deprecatedExclusionParams.filter((deprecatedParam) => {
            const deprecatedConfigValue = config[deprecatedParam];
            return !!deprecatedConfigValue && deprecatedConfigValue.length > 0;
        });
        if (usedDeprecatedParams.length > 0) {
            logger_1.default.warn(`Usage of the ${usedDeprecatedParams.join(', ')} exclusion ${usedDeprecatedParams.length > 1 ? 'params are' : 'param is'} deprecated and may be removed from future major versions. See: https://github.com/auth0/auth0-deploy-cli/issues/451#user-content-deprecated-exclusion-props for details.`);
        }
    })(config);
    const accessToken = yield (() => __awaiter(void 0, void 0, void 0, function* () {
        const { AUTH0_DOMAIN, AUTH0_CLIENT_ID, AUTH0_ACCESS_TOKEN, AUTH0_CLIENT_SECRET, AUTH0_CLIENT_SIGNING_KEY_PATH, AUTH0_CLIENT_SIGNING_ALGORITHM, } = config;
        if (!!AUTH0_ACCESS_TOKEN)
            return AUTH0_ACCESS_TOKEN;
        if (!AUTH0_CLIENT_SECRET && !AUTH0_CLIENT_SIGNING_KEY_PATH) {
            throw new Error('need to supply either `AUTH0_ACCESS_TOKEN`, `AUTH0_CLIENT_SECRET` or `AUTH0_CLIENT_SIGNING_KEY_PATH`');
        }
        const authClient = (() => {
            if (!!AUTH0_CLIENT_SECRET) {
                return new auth0_1.AuthenticationClient({
                    domain: AUTH0_DOMAIN,
                    clientId: AUTH0_CLIENT_ID,
                    clientSecret: AUTH0_CLIENT_SECRET,
                });
            }
            return new auth0_1.AuthenticationClient({
                domain: AUTH0_DOMAIN,
                clientId: AUTH0_CLIENT_ID,
                clientAssertionSigningKey: (0, fs_1.readFileSync)(AUTH0_CLIENT_SIGNING_KEY_PATH),
                clientAssertionSigningAlg: !!AUTH0_CLIENT_SIGNING_ALGORITHM
                    ? AUTH0_CLIENT_SIGNING_ALGORITHM
                    : undefined,
            });
        })();
        const clientCredentials = yield authClient.clientCredentialsGrant({
            audience: config.AUTH0_AUDIENCE
                ? config.AUTH0_AUDIENCE
                : `https://${config.AUTH0_DOMAIN}/api/v2/`,
        });
        return clientCredentials.access_token;
    }))();
    const mgmtClient = new auth0_1.ManagementClient({
        domain: config.AUTH0_DOMAIN,
        token: accessToken,
        retry: { maxRetries: config.AUTH0_API_MAX_RETRIES || 10, enabled: true },
        headers: {
            'User-agent': `deploy-cli/${packageVersion} (node.js/${process.version.replace('v', '')})`,
        },
    });
    const inputFile = config.AUTH0_INPUT_FILE;
    const ensureObject = (key, value) => {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch (e) {
                logger_1.default.debug(`Cannot convert config.${key} to an object. Error: ${e.message}`);
                return value;
            }
        }
        return value;
    };
    nonPrimitiveProps.forEach((key) => {
        if (config[key]) {
            //@ts-ignore because this method of config overwriting technically functions
            config[key] = ensureObject(key, config[key]);
        }
    });
    if (typeof inputFile === 'object') {
        return new yaml_1.default(config, mgmtClient);
    }
    if ((0, utils_1.isDirectory)(inputFile)) {
        return new directory_1.default(config, mgmtClient);
    }
    const ext = path_1.default.extname(inputFile);
    if (ext === '.yaml' || ext === '.yml') {
        return new yaml_1.default(config, mgmtClient);
    }
    throw new Error(`Unable to determine context processor to load for file ${inputFile}, does it exist? `);
});
exports.setupContext = setupContext;
const filterOnlyIncludedResourceTypes = (includedAssetTypes) => ([handlerName, _]) => {
    if (includedAssetTypes === undefined)
        return true;
    return includedAssetTypes.includes(handlerName);
};
exports.filterOnlyIncludedResourceTypes = filterOnlyIncludedResourceTypes;
//# sourceMappingURL=index.js.map