"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapClientID2NameSorted = exports.convertClientIdToName = exports.clearClientArrays = exports.ensureProp = exports.clearTenantFlags = exports.recordsSorter = exports.formatResults = exports.sanitize = exports.stripIdentifiers = exports.toConfigFn = exports.existsMustBeDir = exports.dumpJSON = exports.loadJSON = exports.getFiles = exports.isFile = exports.isDirectory = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
const dot_prop_1 = __importDefault(require("dot-prop"));
const tools_1 = require("./tools");
const logger_1 = __importDefault(require("./logger"));
function isDirectory(filePath) {
    try {
        return fs_extra_1.default.statSync(path_1.default.resolve(filePath)).isDirectory();
    }
    catch (err) {
        return false;
    }
}
exports.isDirectory = isDirectory;
function isFile(filePath) {
    try {
        return fs_extra_1.default.statSync(path_1.default.resolve(filePath)).isFile();
    }
    catch (err) {
        return false;
    }
}
exports.isFile = isFile;
function getFiles(folder, exts) {
    if (isDirectory(folder)) {
        return fs_extra_1.default
            .readdirSync(folder)
            .map((f) => path_1.default.join(folder, f))
            .filter((f) => isFile(f) && exts.includes(path_1.default.extname(f)));
    }
    return [];
}
exports.getFiles = getFiles;
function loadJSON(file, opts = {
    disableKeywordReplacement: false,
    mappings: {},
}) {
    try {
        const content = (0, tools_1.loadFileAndReplaceKeywords)(file, {
            mappings: opts.mappings,
            disableKeywordReplacement: opts.disableKeywordReplacement,
        });
        return JSON.parse(content);
    }
    catch (e) {
        throw new Error(`Error parsing JSON from metadata file: ${file}, because: ${e.message}`);
    }
}
exports.loadJSON = loadJSON;
function dumpJSON(file, mappings) {
    try {
        logger_1.default.info(`Writing ${file}`);
        const jsonBody = JSON.stringify(mappings, null, 2);
        fs_extra_1.default.writeFileSync(file, jsonBody.endsWith('\n') ? jsonBody : `${jsonBody}\n`);
    }
    catch (e) {
        throw new Error(`Error writing JSON to metadata file: ${file}, because: ${e.message}`);
    }
}
exports.dumpJSON = dumpJSON;
function existsMustBeDir(folder) {
    if (fs_extra_1.default.existsSync(folder)) {
        if (!isDirectory(folder)) {
            throw new Error(`Expected ${folder} to be a folder but got a file?`);
        }
        return true;
    }
    return false;
}
exports.existsMustBeDir = existsMustBeDir;
function toConfigFn(data) {
    return (key) => data[key];
}
exports.toConfigFn = toConfigFn;
function stripIdentifiers(auth0, assets) {
    const updated = Object.assign({}, assets);
    // Some of the object identifiers are required to perform updates.
    // Don't strip these object id's
    const ignore = [
        'actions',
        'rulesConfigs',
        'emailTemplates',
        'guardianFactors',
        'guardianFactorProviders',
        'guardianFactorTemplates',
    ];
    // Optionally Strip identifiers
    auth0.handlers.forEach((h) => {
        if (ignore.includes(h.type))
            return;
        const exist = updated[h.type];
        // All objects with the identifier field is an array. This could change in future.
        if (Array.isArray(exist)) {
            updated[h.type] = exist.map((o) => {
                const newObj = Object.assign({}, o);
                delete newObj[h.id];
                return newObj;
            });
        }
    });
    return updated;
}
exports.stripIdentifiers = stripIdentifiers;
function sanitize(str) {
    return (0, sanitize_filename_1.default)(str, { replacement: '-' });
}
exports.sanitize = sanitize;
function formatResults(item) {
    if (!item || typeof item !== 'object') {
        return item;
    }
    const importantFields = {
        name: null,
        client_id: null,
        audience: null,
        template: null,
        identifier: null,
        strategy: null,
        script: null,
        stage: null,
        id: null,
    };
    const result = Object.assign({}, importantFields);
    Object.entries(item)
        .sort()
        .forEach(([key, value]) => {
        result[key] = value;
    });
    Object.keys(importantFields).forEach((key) => {
        if (result[key] === null)
            delete result[key];
    });
    return result;
}
exports.formatResults = formatResults;
function recordsSorter(a, b) {
    const importantFields = ['name', 'key', 'client_id', 'template'];
    for (let i = 0; i < importantFields.length; i += 1) {
        const key = importantFields[i];
        if (a[key] && b[key]) {
            return a[key] > b[key] ? 1 : -1;
        }
    }
    return 0;
}
exports.recordsSorter = recordsSorter;
function clearTenantFlags(tenant) {
    if (tenant.flags && !Object.keys(tenant.flags).length) {
        delete tenant.flags;
    }
}
exports.clearTenantFlags = clearTenantFlags;
function ensureProp(obj, props) {
    const value = '';
    if (!dot_prop_1.default.has(obj, props)) {
        dot_prop_1.default.set(obj, props, value);
    }
}
exports.ensureProp = ensureProp;
function clearClientArrays(client) {
    const propsToClear = ['allowed_clients', 'allowed_logout_urls', 'allowed_origins', 'callbacks'];
    //If designated properties are null, set them as empty arrays instead
    Object.keys(client).forEach((prop) => {
        if (propsToClear.indexOf(prop) >= 0 && !client[prop]) {
            //TODO: understand why setting as empty array instead of deleting null prop. Ex: `delete client[prop]`
            client[prop] = [];
        }
    });
    return client;
}
exports.clearClientArrays = clearClientArrays;
function convertClientIdToName(clientId, knownClients = []) {
    try {
        const found = knownClients.find((c) => c.client_id === clientId);
        return (found && found.name) || clientId;
    }
    catch (e) {
        return clientId;
    }
}
exports.convertClientIdToName = convertClientIdToName;
function mapClientID2NameSorted(enabledClients, knownClients) {
    return [
        ...(enabledClients || []).map((clientId) => convertClientIdToName(clientId, knownClients)),
    ].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
}
exports.mapClientID2NameSorted = mapClientID2NameSorted;
//# sourceMappingURL=utils.js.map