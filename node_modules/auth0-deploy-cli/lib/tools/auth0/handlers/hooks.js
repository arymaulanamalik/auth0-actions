"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = exports.excludeSchema = void 0;
const default_1 = __importDefault(require("./default"));
const constants_1 = __importDefault(require("../../constants"));
const logger_1 = __importDefault(require("../../../logger"));
const utils_1 = require("../../utils");
const ALLOWED_TRIGGER_IDS = [
    'credentials-exchange',
    'pre-user-registration',
    'post-user-registration',
    'post-change-password',
    'send-phone-message',
];
exports.excludeSchema = {
    type: 'array',
    items: { type: 'string' },
};
exports.schema = {
    type: 'array',
    items: {
        type: 'object',
        default: [],
        properties: {
            script: {
                type: 'string',
                description: "A script that contains the hook's code",
                default: '',
            },
            name: {
                type: 'string',
                description: "The name of the hook. Can only contain alphanumeric characters, spaces and '-'. Can neither start nor end with '-' or spaces",
                pattern: '^[^-\\s][a-zA-Z0-9-\\s]+[^-\\s]$',
            },
            enabled: {
                type: 'boolean',
                description: 'true if the hook is active, false otherwise',
                default: false,
            },
            triggerId: {
                type: 'string',
                description: "The hooks's trigger ID",
                enum: ALLOWED_TRIGGER_IDS,
            },
            secrets: {
                type: 'object',
                description: 'List of key-value pairs containing secrets available to the hook.',
                default: {},
            },
            dependencies: {
                type: 'object',
                default: {},
                description: 'List of key-value pairs of NPM dependencies available to the hook.',
            },
        },
        required: ['script', 'name', 'triggerId'],
    },
};
const getCertainHook = (hooks, name, triggerId) => {
    let result = null;
    hooks.forEach((hook) => {
        if (hook.name === name && hook.triggerId === triggerId) {
            result = hook;
        }
    });
    return result;
};
const getActive = (hooks) => {
    const result = {};
    ALLOWED_TRIGGER_IDS.forEach((type) => {
        result[type] = hooks.filter((h) => h.active && h.triggerId === type);
    });
    return result;
};
class HooksHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'hooks', stripUpdateFields: ['id', 'triggerId'] }));
    }
    objString(hook) {
        return super.objString({ name: hook.name, triggerId: hook.triggerId });
    }
    processSecrets(hooks) {
        return __awaiter(this, void 0, void 0, function* () {
            const allHooks = yield this.getType(true);
            if (allHooks === null)
                return;
            const changes = {
                create: [],
                update: [],
                del: [],
                conflicts: [],
            };
            hooks.forEach((hook) => {
                const current = getCertainHook(allHooks, hook.name, hook.triggerId);
                if (current) {
                    // if the hook was deleted we don't care about its secrets
                    const oldSecrets = current.secrets || {};
                    const newSecrets = hook.secrets || {};
                    const create = {};
                    const update = {};
                    const del = [];
                    Object.keys(newSecrets).forEach((key) => {
                        if (!oldSecrets[key]) {
                            create[key] = newSecrets[key];
                        }
                        else if (newSecrets[key] !== constants_1.default.HOOKS_HIDDEN_SECRET_VALUE) {
                            update[key] = newSecrets[key];
                        }
                    });
                    Object.keys(oldSecrets).forEach((key) => {
                        if (!newSecrets[key]) {
                            del.push(key);
                        }
                    });
                    if (Object.keys(create).length)
                        changes.create.push({ hookId: current.id, secrets: create });
                    if (Object.keys(update).length)
                        changes.update.push({ hookId: current.id, secrets: update });
                    if (del.length)
                        changes.del.push({ hookId: current.id, secrets: del });
                }
            });
            yield Promise.all(changes.del.map((data) => __awaiter(this, void 0, void 0, function* () {
                yield this.client.hooks.removeSecrets({ id: data.hookId }, data.secrets);
            })));
            yield Promise.all(changes.update.map((data) => __awaiter(this, void 0, void 0, function* () {
                yield this.client.hooks.updateSecrets({ id: data.hookId }, data.secrets);
            })));
            yield Promise.all(changes.create.map((data) => __awaiter(this, void 0, void 0, function* () {
                yield this.client.hooks.addSecrets({ id: data.hookId }, data.secrets);
            })));
        });
    }
    //@ts-ignore because hooks use a special reload argument
    getType(reload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.existing && !reload) {
                return this.existing;
            }
            // in case client version does not support hooks
            if (!this.client.hooks || typeof this.client.hooks.getAll !== 'function') {
                return [];
            }
            try {
                const hooks = yield this.client.hooks.getAll({ paginate: true, include_totals: true });
                // hooks.getAll does not return code and secrets, we have to fetch hooks one-by-one
                this.existing = yield Promise.all(hooks.map((hook) => this.client.hooks
                    .get({ id: hook.id })
                    .then((hookWithCode) => this.client.hooks
                    .getSecrets({ id: hook.id })
                    .then((secrets) => (Object.assign(Object.assign({}, hookWithCode), { secrets }))))));
                return this.existing;
            }
            catch (err) {
                if (err.statusCode === 404 || err.statusCode === 501) {
                    return [];
                }
                if ((0, utils_1.isDeprecatedError)(err)) {
                    return null;
                }
                throw err;
            }
        });
    }
    calcChanges(assets) {
        const _super = Object.create(null, {
            calcChanges: { get: () => super.calcChanges }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { del, update, create, conflicts } = yield _super.calcChanges.call(this, assets);
            // strip secrets before hooks creating/updating, secrets have to be handled separately
            const stripSecrets = (list) => list.map((item) => (Object.assign(Object.assign({}, item), { secrets: undefined })));
            return {
                del,
                update: stripSecrets(update),
                create: stripSecrets(create),
                conflicts: stripSecrets(conflicts),
            };
        });
    }
    validate(assets) {
        const _super = Object.create(null, {
            validate: { get: () => super.validate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { hooks } = assets;
            // Do nothing if not set
            if (!hooks)
                return;
            const activeHooks = getActive(hooks);
            ALLOWED_TRIGGER_IDS.forEach((type) => {
                if (activeHooks[type].length > 1) {
                    // There can be only one!
                    const conflict = activeHooks[type].map((h) => h.name).join(', ');
                    const err = new Error(`Only one active hook allowed for "${type}" extensibility point. Conflicting hooks: ${conflict}`);
                    //@ts-ignore need to investigate if appending status actually works here
                    err.status = 409;
                    throw err;
                }
            });
            yield _super.validate.call(this, assets);
        });
    }
    processChanges(assets) {
        const _super = Object.create(null, {
            processChanges: { get: () => super.processChanges }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { hooks } = assets;
            // Do nothing if not set
            if (!hooks)
                return;
            logger_1.default.warn('Hooks are deprecated, migrate to using actions instead. See: https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions for more information.');
            try {
                // Figure out what needs to be updated vs created
                const changes = yield this.calcChanges(assets);
                yield _super.processChanges.call(this, assets, {
                    del: changes.del,
                    create: changes.create,
                    update: changes.update,
                    conflicts: changes.conflicts,
                });
                yield this.processSecrets(hooks);
            }
            catch (err) {
                if ((0, utils_1.isDeprecatedError)(err)) {
                    logger_1.default.warn('Failed to update hooks because functionality has been deprecated in favor of actions. See: https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions for more information.');
                    return;
                }
                throw err;
            }
        });
    }
}
exports.default = HooksHandler;
//# sourceMappingURL=hooks.js.map