"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
const default_1 = __importDefault(require("./default"));
const types_1 = require("../../../types");
const lodash_1 = require("lodash");
const promptTypes = [
    'login',
    'login-id',
    'login-password',
    'login-email-verification',
    'signup',
    'signup-id',
    'signup-password',
    'reset-password',
    'consent',
    'mfa-push',
    'mfa-otp',
    'mfa-voice',
    'mfa-phone',
    'mfa-webauthn',
    'mfa-sms',
    'mfa-email',
    'mfa-recovery-code',
    'mfa',
    'status',
    'device-flow',
    'email-verification',
    'email-otp-challenge',
    'organizations',
    'invitation',
    'common',
];
const screenTypes = [
    'login',
    'login-id',
    'login-password',
    'login-email-verification',
    'signup',
    'signup-id',
    'signup-password',
    'reset-password-request',
    'reset-password-email',
    'reset-password',
    'reset-password-success',
    'reset-password-error',
    'consent',
    'status',
    'mfa-detect-browser-capabilities',
    'mfa-enroll-result',
    'mfa-login-options',
    'mfa-begin-enroll-options',
    'mfa-otp-enrollment-qr',
    'mfa-otp-enrollment-code',
    'mfa-otp-challenge',
    'mfa-voice-challenge',
    'mfa-sms-challenge',
    'mfa-recovery-code-enrollment',
    'mfa-recovery-code-challenge',
    'mfa-country-codes',
    'mfa-sms-enrollment',
    'mfa-voice-enrollment',
    'mfa-phone-challenge',
    'mfa-phone-enrollment',
    'mfa-webauthn-roaming-enrollment',
    'mfa-webauthn-platform-enrollment',
    'mfa-webauthn-platform-challenge',
    'mfa-webauthn-roaming-challenge',
    'mfa-webauthn-change-key-nickname',
    'mfa-webauthn-enrollment-success',
    'mfa-webauthn-error',
    'mfa-webauthn-not-available-error',
    'mfa-sms-list',
    'mfa-email-challenge',
    'mfa-email-list',
    'mfa-push-welcome',
    'mfa-push-list',
    'mfa-push-enrollment-qr',
    'mfa-push-enrollment-code',
    'mfa-push-success',
    'mfa-push-challenge-push',
    'device-code-activation',
    'device-code-activation-allowed',
    'device-code-activation-denied',
    'device-code-confirmation',
    'email-verification-result',
    'email-otp-challenge',
    'redeem-ticket',
    'organization-selection',
    'accept-invitation',
];
exports.schema = {
    type: 'object',
    properties: {
        universal_login_experience: {
            type: 'string',
            enum: ['new', 'classic'],
        },
        webauthn_platform_first_factor: {
            type: 'boolean',
        },
        identifier_first: {
            type: 'boolean',
        },
        customText: {
            type: 'object',
            properties: types_1.languages.reduce((acc, language) => {
                return Object.assign(Object.assign({}, acc), { [language]: {
                        type: 'object',
                        properties: promptTypes.reduce((acc, promptTypes) => {
                            return Object.assign(Object.assign({}, acc), { [promptTypes]: {
                                    type: 'object',
                                    properties: screenTypes.reduce((acc, screenTypes) => {
                                        return Object.assign(Object.assign({}, acc), { [screenTypes]: {
                                                type: 'object',
                                            } });
                                    }, {}),
                                } });
                        }, {}),
                    } });
            }, {}),
        },
    },
};
class PromptsHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'prompts' }));
    }
    objString({ customText }) {
        return `Prompts settings${!!customText ? ' and prompts custom text' : ''}`;
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const promptsSettings = yield this.client.prompts.getSettings();
            const customText = yield this.getCustomTextSettings();
            return Object.assign(Object.assign({}, promptsSettings), { customText });
        });
    }
    getCustomTextSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            const supportedLanguages = yield this.client.tenant
                .getSettings()
                .then(({ enabled_locales }) => {
                if (enabled_locales === undefined)
                    return []; // In rare cases, private cloud tenants may not have `enabled_locales` defined
                return enabled_locales;
            });
            return this.client.pool
                .addEachTask({
                data: supportedLanguages
                    .map((language) => promptTypes.map((promptType) => ({ promptType, language })))
                    .reduce((acc, val) => acc.concat(val), []) || [],
                generator: ({ promptType, language }) => this.client.prompts
                    .getCustomTextByLanguage({
                    prompt: promptType,
                    language,
                })
                    .then((customTextData) => {
                    if ((0, lodash_1.isEmpty)(customTextData))
                        return null;
                    return {
                        language,
                        [promptType]: Object.assign({}, customTextData),
                    };
                }),
            })
                .promise()
                .then((customTextData) => {
                return customTextData
                    .filter((customTextData) => {
                    return customTextData !== null;
                })
                    .reduce((acc, customTextItem) => {
                    if ((customTextItem === null || customTextItem === void 0 ? void 0 : customTextItem.language) === undefined)
                        return acc;
                    const { language } = customTextItem, customTextSettings = __rest(customTextItem, ["language"]);
                    return Object.assign(Object.assign({}, acc), { [language]: !!acc[language]
                            ? Object.assign(Object.assign({}, acc[language]), customTextSettings) : Object.assign({}, customTextSettings) });
                }, {});
            });
        });
    }
    processChanges(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prompts } = assets;
            if (!prompts)
                return;
            const { customText } = prompts, promptSettings = __rest(prompts, ["customText"]);
            if (!(0, lodash_1.isEmpty)(promptSettings)) {
                yield this.client.prompts.updateSettings({}, promptSettings);
            }
            yield this.updateCustomTextSettings(customText);
            this.updated += 1;
            this.didUpdate(prompts);
        });
    }
    updateCustomTextSettings(customText) {
        return __awaiter(this, void 0, void 0, function* () {
            /*
              Note: deletes are not currently supported
            */
            if (!customText)
                return;
            yield this.client.pool
                .addEachTask({
                data: Object.keys(customText).flatMap((language) => {
                    const languageScreenTypes = customText[language];
                    if (!languageScreenTypes)
                        return [];
                    return Object.keys(languageScreenTypes).map((prompt) => {
                        const body = languageScreenTypes[prompt] || {};
                        return {
                            body,
                            language,
                            prompt,
                        };
                    });
                }),
                generator: ({ prompt, language, body }) => this.client.prompts.updateCustomTextByLanguage({
                    prompt,
                    language,
                    body,
                }),
            })
                .promise();
        });
    }
}
exports.default = PromptsHandler;
//# sourceMappingURL=prompts.js.map