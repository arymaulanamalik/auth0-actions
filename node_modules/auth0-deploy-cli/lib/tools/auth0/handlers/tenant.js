"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUnallowedTenantFlags = exports.allowedTenantFlags = exports.schema = void 0;
const validationError_1 = __importDefault(require("../../validationError"));
const default_1 = __importStar(require("./default"));
const pages_1 = require("./pages");
const utils_1 = require("../../utils");
const logger_1 = __importDefault(require("../../../logger"));
exports.schema = {
    type: 'object',
};
const blockPageKeys = [
    ...Object.keys(pages_1.pageNameMap),
    ...Object.values(pages_1.pageNameMap),
    ...pages_1.supportedPages,
];
class TenantHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'tenant' }));
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const tenant = yield this.client.tenant.getSettings();
            tenant.flags = (0, exports.removeUnallowedTenantFlags)(tenant.flags);
            this.existing = tenant;
            blockPageKeys.forEach((key) => {
                if (tenant[key])
                    delete tenant[key];
            });
            return tenant;
        });
    }
    validate(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tenant } = assets;
            // Nothing to validate?
            if (!tenant)
                return;
            const pageKeys = Object.keys(tenant).filter((k) => blockPageKeys.includes(k));
            if (pageKeys.length > 0) {
                throw new validationError_1.default(`The following pages ${(0, utils_1.convertJsonToString)(pageKeys)} were found in tenant settings. Pages should be set separately. Please refer to the documentation.`);
            }
        });
    }
    // Run after other updates so objected can be referenced such as default directory
    processChanges(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tenant } = assets;
            // Do nothing if not set
            if (!tenant)
                return;
            const updatedTenant = Object.assign({}, tenant);
            if ('flags' in updatedTenant) {
                updatedTenant.flags = (0, exports.removeUnallowedTenantFlags)(tenant.flags);
                if (Object.keys(updatedTenant.flags).length === 0) {
                    delete updatedTenant.flags;
                }
            }
            if (updatedTenant && Object.keys(updatedTenant).length > 0) {
                yield this.client.tenant.updateSettings(updatedTenant);
                this.updated += 1;
                this.didUpdate(updatedTenant);
            }
        });
    }
}
__decorate([
    (0, default_1.order)('100')
], TenantHandler.prototype, "processChanges", null);
exports.default = TenantHandler;
/*
 Tenant flags are used to facilitate a number of functionalities, some
 public, some internal. The subset of flags that are allowed to be updated
 in the context of the Deploy CLI is based on wether they're publicly exposed
 in the Auth0 API docs:

 https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings
*/
exports.allowedTenantFlags = [
    'change_pwd_flow_v1',
    'enable_client_connections',
    'enable_apis_section',
    'enable_pipeline2',
    'enable_dynamic_client_registration',
    'enable_custom_domain_in_emails',
    'allow_legacy_tokeninfo_endpoint',
    'enable_legacy_profile',
    'enable_idtoken_api2',
    'enable_public_signup_user_exists_error',
    'allow_legacy_delegation_grant_types',
    'allow_legacy_ro_grant_types',
    'enable_sso',
    'disable_clickjack_protection_headers',
    'no_disclose_enterprise_connections',
    'disable_management_api_sms_obfuscation',
    'enforce_client_authentication_on_passwordless_start',
    'trust_azure_adfs_email_verified_connection_property',
    'enable_adfs_waad_email_verification',
    'revoke_refresh_token_grant',
    'dashboard_log_streams_next',
    'dashboard_insights_view',
    'disable_fields_map_fix',
    'require_pushed_authorization_requests',
    'mfa_show_factor_list_on_enrollment',
];
const removeUnallowedTenantFlags = (proposedFlags) => {
    if (proposedFlags === undefined)
        return {};
    const removedFlags = [];
    const filteredFlags = Object.keys(proposedFlags).reduce((acc, proposedKey) => {
        const isAllowedFlag = exports.allowedTenantFlags.includes(proposedKey);
        if (!isAllowedFlag) {
            removedFlags.push(proposedKey);
            return acc;
        }
        return Object.assign(Object.assign({}, acc), { [proposedKey]: proposedFlags[proposedKey] });
    }, {});
    if (removedFlags.length > 0) {
        logger_1.default.warn(`The following tenant flag${removedFlags.length > 1 ? 's have not been' : ' has not been'} updated because deemed incompatible with the target tenant: ${removedFlags.join(', ')}
      ${removedFlags.length > 1 ? 'These flags' : 'This flag'} can likely be removed from the tenant definition file. If you believe this removal is an error, please report via a Github issue.`);
    }
    return filteredFlags;
};
exports.removeUnallowedTenantFlags = removeUnallowedTenantFlags;
//# sourceMappingURL=tenant.js.map