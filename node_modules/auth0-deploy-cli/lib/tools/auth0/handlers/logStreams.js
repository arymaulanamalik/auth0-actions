"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
const default_1 = __importDefault(require("./default"));
exports.schema = {
    type: 'array',
    items: {
        type: 'object',
        properties: {
            id: { type: 'string' },
            type: { type: 'string' },
            name: { type: 'string' },
            status: { type: 'string', enum: ['active', 'paused', 'suspended'] },
            sink: { type: 'object' },
            filters: {
                type: 'array',
                items: {
                    type: 'object',
                },
            },
        },
        required: ['name'],
    },
};
class LogStreamsHandler extends default_1.default {
    constructor(config) {
        super(Object.assign(Object.assign({}, config), { type: 'logStreams', stripUpdateFields: ['type'], stripCreateFields: ['status', 'sink.awsPartnerEventSource'], sensitiveFieldsToObfuscate: [
                'sink.httpAuthorization',
                'sink.splunkToken',
                'sink.datadogApiKey',
            ] }));
    }
    objString(item) {
        return super.objString(item.name);
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.existing) {
                return this.existing;
            }
            const logStreams = yield this.client.logStreams.getAll({ paginate: false }).then((logStreams) => logStreams.map((logStream) => {
                if (logStream.status === 'suspended')
                    delete logStream.status;
                return logStream;
            }));
            this.existing = logStreams;
            return logStreams;
        });
    }
    processChanges(assets) {
        const _super = Object.create(null, {
            processChanges: { get: () => super.processChanges }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { logStreams } = assets;
            if (!logStreams)
                return;
            const changes = yield this.calcChanges(assets).then((changes) => {
                return Object.assign(Object.assign({}, changes), { update: changes.update.map((update) => {
                        if (update.type === 'eventbridge' || update.type === 'eventgrid') {
                            delete update.sink;
                        }
                        if (update.status === 'suspended') {
                            // @ts-ignore because while status is usually expected for update payloads, it is ok to be omitted
                            // for suspended log streams. Setting as `active` in these instances would probably be ok
                            // but bit presumptuous, let suspended log streams remain suspended.
                            delete update.status;
                        }
                        return update;
                    }) });
            });
            yield _super.processChanges.call(this, assets, changes);
        });
    }
}
exports.default = LogStreamsHandler;
//# sourceMappingURL=logStreams.js.map