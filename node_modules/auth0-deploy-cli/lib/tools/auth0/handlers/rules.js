"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = exports.excludeSchema = void 0;
const validationError_1 = __importDefault(require("../../validationError"));
const utils_1 = require("../../utils");
const default_1 = __importDefault(require("./default"));
const logger_1 = __importDefault(require("../../../logger"));
const calculateChanges_1 = require("../../calculateChanges");
exports.excludeSchema = {
    type: 'array',
    items: { type: 'string' },
};
exports.schema = {
    type: 'array',
    items: {
        type: 'object',
        default: [],
        properties: {
            script: {
                type: 'string',
                description: "A script that contains the rule's code",
                default: '',
            },
            name: {
                type: 'string',
                description: "The name of the rule. Can only contain alphanumeric characters, spaces and '-'. Can neither start nor end with '-' or spaces",
                pattern: '^[^-\\s][a-zA-Z0-9-\\s]+[^-\\s]$',
            },
            order: {
                type: ['number', 'null'],
                description: "The rule's order in relation to other rules. A rule with a lower order than another rule executes first.",
                default: null,
            },
            enabled: {
                type: 'boolean',
                description: 'true if the rule is enabled, false otherwise',
                default: true,
            },
            stage: {
                type: 'string',
                description: "The rule's execution stage",
                default: 'login_success',
                enum: ['login_success', 'login_failure', 'pre_authorize'],
            },
        },
        required: ['name'],
    },
};
class RulesHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'rules', stripUpdateFields: ['stage'] }));
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.existing)
                    return this.existing;
                this.existing = yield this.client.rules.getAll({ paginate: true, include_totals: true });
                return this.existing;
            }
            catch (err) {
                if ((0, utils_1.isDeprecatedError)(err)) {
                    return null;
                }
                throw err;
            }
        });
    }
    objString(rule) {
        return super.objString({ name: rule.name, order: rule.order });
    }
    calcChanges(assets, includeExcluded = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let { rules } = assets;
            const excludedRules = (assets.exclude && assets.exclude.rules) || [];
            let existing = yield this.getType();
            if (existing === null) {
                return {
                    del: [],
                    update: [],
                    conflicts: [],
                    create: [],
                    reOrder: [],
                };
            }
            // Filter excluded rules
            if (!includeExcluded) {
                rules = rules.filter((r) => !excludedRules.includes(r.name));
                existing = existing.filter((r) => !excludedRules.includes(r.name));
            }
            // Figure out what needs to be updated vs created
            const { del, update, create, conflicts } = (0, calculateChanges_1.calculateChanges)({
                handler: this,
                assets: rules,
                existing,
                identifiers: this.identifiers,
                allowDelete: !!this.config('AUTH0_ALLOW_DELETE'),
            });
            // Figure out the rules that need to be re-ordered
            const futureRules = [...create, ...update];
            const futureMaxOrder = Math.max(...futureRules.map((r) => r.order));
            const existingMaxOrder = Math.max(...existing.map((r) => r.order));
            let nextOrderNo = Math.max(futureMaxOrder, existingMaxOrder);
            //@ts-ignore because we know reOrder is Asset[]
            const reOrder = futureRules.reduce((accum, r) => {
                if (existing === null)
                    return accum;
                const conflict = existing.find((f) => r.order === f.order && r.name !== f.name);
                if (conflict !== undefined) {
                    nextOrderNo += 1;
                    return [
                        ...accum,
                        Object.assign(Object.assign({}, conflict), { order: nextOrderNo }),
                    ];
                }
                return accum;
            }, []);
            return {
                del,
                update,
                create,
                reOrder,
                conflicts,
            };
        });
    }
    validate(assets) {
        const _super = Object.create(null, {
            validate: { get: () => super.validate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { rules } = assets;
            // Do nothing if not set
            if (!rules)
                return;
            const excludedRules = (assets.exclude && assets.exclude.rules) || [];
            // Figure out what needs to be updated vs created
            const { update, create, del } = yield this.calcChanges(assets, true);
            // Include del rules which are actually not going to be deleted but are excluded
            // they can still muck up the ordering so we must take it into consideration.
            const futureRules = [
                ...create,
                ...update,
                ...del.filter((r) => excludedRules.includes(r.name)),
            ];
            // Detect rules with the same order
            const rulesSameOrder = (0, utils_1.duplicateItems)(futureRules, 'order');
            if (rulesSameOrder.length > 0) {
                const formatted = rulesSameOrder.map((dups) => dups.map((d) => `${d.name}`));
                throw new validationError_1.default(`There are multiple rules for the following stage-order combinations
      ${(0, utils_1.convertJsonToString)(formatted)}.
       Only one rule must be defined for the same order number in a stage.`);
            }
            // Detect Rules that are changing stage as it's not allowed.
            const existing = yield this.getType();
            if (existing === null)
                return;
            const stateChanged = futureRules
                .reduce((changed, rule) => [
                ...changed,
                ...existing.filter((r) => rule.name.toLowerCase() === r.name.toLowerCase() && r.stage !== rule.stage),
            ], [])
                .map((r) => r.name);
            if (stateChanged.length > 0) {
                throw new validationError_1.default(`The following rules changed stage which is not allowed:
      ${(0, utils_1.convertJsonToString)(stateChanged)}.
      Rename the rules to recreate them and avoid this error.`);
            }
            yield _super.validate.call(this, assets);
        });
    }
    processChanges(assets) {
        const _super = Object.create(null, {
            processChanges: { get: () => super.processChanges }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { rules } = assets;
            // Do nothing if not set
            if (!rules)
                return;
            logger_1.default.warn('Rules are deprecated, migrate to using actions instead. See: https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions for more information.');
            try {
                // Figure out what needs to be updated vs created
                const changes = yield this.calcChanges(assets);
                // Temporally re-order rules with conflicting ordering
                yield this.client.pool
                    .addEachTask({
                    data: changes.reOrder,
                    generator: (rule) => this.client.rules
                        .update({ id: rule.id }, (0, utils_1.stripFields)(rule, this.stripUpdateFields))
                        .then(() => {
                        const updated = {
                            name: rule.name,
                            stage: rule.stage,
                            order: rule.order,
                            id: rule.id,
                        };
                        logger_1.default.info(`Temporally re-order Rule ${(0, utils_1.convertJsonToString)(updated)}`);
                    }),
                })
                    .promise();
                yield _super.processChanges.call(this, assets, {
                    del: changes.del,
                    create: changes.create,
                    update: changes.update,
                    conflicts: changes.conflicts,
                });
            }
            catch (err) {
                if ((0, utils_1.isDeprecatedError)(err)) {
                    logger_1.default.warn('Failed to update rules because functionality has been deprecated in favor of actions. See: https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions for more information.');
                    return;
                }
                throw err;
            }
        });
    }
}
exports.default = RulesHandler;
//# sourceMappingURL=rules.js.map