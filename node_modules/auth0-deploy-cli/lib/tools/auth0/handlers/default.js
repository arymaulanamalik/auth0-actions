"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.order = void 0;
const validationError_1 = __importDefault(require("../../validationError"));
const utils_1 = require("../../utils");
const logger_1 = __importDefault(require("../../../logger"));
const calculateChanges_1 = require("../../calculateChanges");
function order(value) {
    return function decorator(t, n, descriptor) {
        descriptor.value.order = value; // eslint-disable-line
        return descriptor;
    };
}
exports.order = order;
class APIHandler {
    constructor(options) {
        this.config = options.config;
        this.type = options.type;
        this.id = options.id || 'id';
        this.client = options.client;
        this.existing = null;
        this.identifiers = options.identifiers || ['id', 'name'];
        this.objectFields = options.objectFields || [];
        this.stripUpdateFields = [...(options.stripUpdateFields || []), this.id];
        this.sensitiveFieldsToObfuscate = options.sensitiveFieldsToObfuscate || [];
        this.stripCreateFields = options.stripCreateFields || [];
        this.functions = Object.assign({ getAll: 'getAll', create: 'create', delete: 'delete', update: 'update' }, (options.functions || {}));
        this.updated = 0;
        this.created = 0;
        this.deleted = 0;
    }
    getClientFN(fn) {
        if (typeof fn === 'string') {
            const client = this.client[this.type];
            return client[fn].bind(client);
        }
        return fn;
    }
    didDelete(item) {
        logger_1.default.info(`Deleted [${this.type}]: ${this.objString(item)}`);
    }
    didCreate(item) {
        logger_1.default.info(`Created [${this.type}]: ${this.objString(item)}`);
    }
    didUpdate(item) {
        logger_1.default.info(`Updated [${this.type}]: ${this.objString(item)}`);
    }
    objString(item) {
        return (0, utils_1.convertJsonToString)(item);
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            // Each type to impl how to get the existing as its not consistent across the mgnt api.
            throw new Error(`Must implement getType for type ${this.type}`);
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            // Load Asset from Tenant
            const data = yield (() => __awaiter(this, void 0, void 0, function* () {
                const { data, hadSufficientScopes, requiredScopes } = yield (0, utils_1.detectInsufficientScopeError)(this.getType.bind(this));
                if (!hadSufficientScopes) {
                    logger_1.default.warn(`Cannot retrieve ${this.type} due to missing scopes: ${requiredScopes}`);
                    return null;
                }
                logger_1.default.info(`Retrieving ${this.type} data from Auth0`);
                return data;
            }))();
            this.existing = (0, utils_1.obfuscateSensitiveValues)(data, this.sensitiveFieldsToObfuscate);
            return { [this.type]: this.existing };
        });
    }
    calcChanges(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeAssets = assets[this.type];
            // Do nothing if not set
            if (!typeAssets) {
                return {
                    del: [],
                    create: [],
                    conflicts: [],
                    update: [],
                };
            }
            const existing = yield this.getType();
            // Figure out what needs to be updated vs created
            return (0, calculateChanges_1.calculateChanges)({
                handler: this,
                assets: typeAssets,
                allowDelete: !!this.config('AUTH0_ALLOW_DELETE'),
                //@ts-ignore TODO: investigate what happens when `existing` is null
                existing,
                identifiers: this.identifiers,
            });
        });
    }
    validate(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure no duplication in id and name
            const typeAssets = assets[this.type];
            // Do nothing if not set
            if (!Array.isArray(typeAssets))
                return;
            // Do not allow items with same name
            const duplicateNames = (0, utils_1.duplicateItems)(typeAssets, 'name');
            if (duplicateNames.length > 0) {
                const formatted = duplicateNames.map((dups) => dups.map((d) => `${d.name}`));
                throw new validationError_1.default(`There are multiple ${this.type} with the same name combinations
      ${(0, utils_1.convertJsonToString)(formatted)}.
       Names must be unique.`);
            }
            // Do not allow items with same id
            const duplicateIDs = (0, utils_1.duplicateItems)(typeAssets, this.id);
            if (duplicateIDs.length > 0) {
                const formatted = duplicateIDs.map((dups) => dups.map((d) => `${d[this.id]}`));
                throw new validationError_1.default(`There are multiple ${this.type} for the following stage-order combinations
      ${(0, utils_1.convertJsonToString)(formatted)}.
       Only one rule must be defined for the same order number in a stage.`);
            }
        });
    }
    processChanges(assets, changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!changes) {
                changes = yield this.calcChanges(assets);
            }
            const del = changes.del || [];
            const update = changes.update || [];
            const create = changes.create || [];
            const conflicts = changes.conflicts || [];
            logger_1.default.debug(`Start processChanges for ${this.type} [delete:${del.length}] [update:${update.length}], [create:${create.length}], [conflicts:${conflicts.length}]`);
            // Process Deleted
            if (del.length > 0) {
                const allowDelete = this.config('AUTH0_ALLOW_DELETE') === 'true' || this.config('AUTH0_ALLOW_DELETE') === true;
                const byExtension = this.config('EXTENSION_SECRET') &&
                    (this.type === 'rules' || this.type === 'resourceServers');
                const shouldDelete = allowDelete || byExtension;
                if (!shouldDelete) {
                    logger_1.default.warn(`Detected the following ${this.type} should be deleted. Doing so may be destructive.\nYou can enable deletes by setting 'AUTH0_ALLOW_DELETE' to true in the config
        \n${changes.del.map((i) => this.objString(i)).join('\n')}
         `);
                }
                else {
                    yield this.client.pool
                        .addEachTask({
                        data: del || [],
                        generator: (delItem) => {
                            const delFunction = this.getClientFN(this.functions.delete);
                            return delFunction({ [this.id]: delItem[this.id] })
                                .then(() => {
                                this.didDelete(delItem);
                                this.deleted += 1;
                            })
                                .catch((err) => {
                                throw new Error(`Problem deleting ${this.type} ${this.objString(delItem)}\n${err}`);
                            });
                        },
                    })
                        .promise();
                }
            }
            // Process Renaming Entries Temp due to conflicts in names
            yield this.client.pool
                .addEachTask({
                data: conflicts || [],
                generator: (updateItem) => {
                    const updateFN = this.getClientFN(this.functions.update);
                    const params = { [this.id]: updateItem[this.id] };
                    const updatePayload = (() => {
                        let data = (0, utils_1.stripFields)(Object.assign({}, updateItem), this.stripUpdateFields);
                        return (0, utils_1.stripObfuscatedFieldsFromPayload)(data, this.sensitiveFieldsToObfuscate);
                    })();
                    return updateFN(params, updatePayload)
                        .then((data) => this.didUpdate(data))
                        .catch((err) => {
                        throw new Error(`Problem updating ${this.type} ${this.objString(updateItem)}\n${err}`);
                    });
                },
            })
                .promise();
            // Process Creations
            yield this.client.pool
                .addEachTask({
                data: create || [],
                generator: (createItem) => {
                    const createFunction = this.getClientFN(this.functions.create);
                    const createPayload = (() => {
                        const strippedPayload = (0, utils_1.stripFields)(createItem, this.stripCreateFields);
                        return (0, utils_1.stripObfuscatedFieldsFromPayload)(strippedPayload, this.sensitiveFieldsToObfuscate);
                    })();
                    return createFunction(createPayload)
                        .then((data) => {
                        this.didCreate(data);
                        this.created += 1;
                    })
                        .catch((err) => {
                        throw new Error(`Problem creating ${this.type} ${this.objString(createItem)}\n${err}`);
                    });
                },
            })
                .promise();
            // Process Updates and strip fields not allowed in updates
            yield this.client.pool
                .addEachTask({
                data: update || [],
                generator: (updateItem) => {
                    const updateFN = this.getClientFN(this.functions.update);
                    const params = { [this.id]: updateItem[this.id] };
                    const updatePayload = (() => {
                        let data = (0, utils_1.stripFields)(Object.assign({}, updateItem), this.stripUpdateFields);
                        return (0, utils_1.stripObfuscatedFieldsFromPayload)(data, this.sensitiveFieldsToObfuscate);
                    })();
                    return updateFN(params, updatePayload)
                        .then((data) => {
                        this.didUpdate(data);
                        this.updated += 1;
                    })
                        .catch((err) => {
                        throw new Error(`Problem updating ${this.type} ${this.objString(updateItem)}\n${err}`);
                    });
                },
            })
                .promise();
        });
    }
}
exports.default = APIHandler;
//# sourceMappingURL=default.js.map