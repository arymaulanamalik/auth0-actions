"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = exports.pageNameMap = exports.supportedPages = void 0;
const default_1 = __importDefault(require("./default"));
const constants_1 = __importDefault(require("../../constants"));
exports.supportedPages = constants_1.default.PAGE_NAMES.filter((p) => p.includes('.json')).map((p) => p.replace('.json', ''));
exports.pageNameMap = {
    guardian_multifactor: 'guardian_mfa_page',
    password_reset: 'change_password',
    error_page: 'error_page',
};
// With this schema, we can only validate property types but not valid properties on per type basis
exports.schema = {
    type: 'array',
    items: {
        type: 'object',
        properties: {
            name: { type: 'string', enum: exports.supportedPages },
            html: { type: 'string', default: '' },
            url: { type: 'string' },
            show_log_link: { type: 'boolean' },
            enabled: { type: 'boolean' },
        },
        required: ['name'],
    },
};
class PagesHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'pages', identifiers: ['name'] }));
    }
    objString(page) {
        return super.objString({ name: page.name, enabled: page.enabled });
    }
    updateLoginPage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const globalClient = yield this.client.clients.getAll({
                is_global: true,
                paginate: true,
                include_totals: true,
            });
            if (!globalClient[0]) {
                throw new Error('Unable to find global client id when trying to update the login page');
            }
            yield this.client.clients.update({ client_id: globalClient[0].client_id }, {
                custom_login_page: page.html,
                custom_login_page_on: page.enabled,
            });
            this.updated += 1;
            this.didUpdate(page);
        });
    }
    updatePages(pages) {
        return __awaiter(this, void 0, void 0, function* () {
            const toUpdate = pages.filter((p) => exports.supportedPages.includes(p.name));
            const update = toUpdate.reduce((accum, page) => {
                if (exports.supportedPages.includes(page.name)) {
                    const pageName = exports.pageNameMap[page.name];
                    if (!pageName) {
                        throw new Error(`Unable to map page ${page.name} into tenant level page setting`);
                    }
                    accum[pageName] = Object.assign({}, page);
                    delete accum[pageName].name;
                }
                return accum;
            }, {});
            if (Object.keys(update).length) {
                yield this.client.tenant.updateSettings(update);
            }
            toUpdate.forEach((page) => {
                this.updated += 1;
                this.didUpdate(page);
            });
        });
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const pages = [];
            // Login page is handled via the global client
            const globalClient = yield this.client.clients.getAll({
                is_global: true,
                paginate: true,
                include_totals: true,
            });
            if (!globalClient[0]) {
                throw new Error('Unable to find global client id when trying to dump the login page');
            }
            if (globalClient[0].custom_login_page) {
                pages.push({
                    name: 'login',
                    enabled: !!globalClient[0].custom_login_page_on,
                    html: globalClient[0].custom_login_page,
                });
            }
            const tenantSettings = yield this.client.tenant.getSettings();
            Object.entries(exports.pageNameMap).forEach(([key, name]) => {
                const page = tenantSettings[name];
                if (tenantSettings[name]) {
                    pages.push(Object.assign(Object.assign({}, page), { name: key }));
                }
            });
            return pages;
        });
    }
    processChanges(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pages } = assets;
            // Do nothing if not set
            if (!pages)
                return;
            // Login page is handled via the global client
            const loginPage = pages.find((p) => p.name === 'login');
            if (loginPage !== undefined) {
                yield this.updateLoginPage(loginPage);
            }
            // Rest of pages are on tenant level settings
            yield this.updatePages(pages.filter((p) => p.name !== 'login'));
        });
    }
}
exports.default = PagesHandler;
//# sourceMappingURL=pages.js.map