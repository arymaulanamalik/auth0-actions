"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMarketplaceAction = exports.schema = void 0;
const lodash_1 = __importDefault(require("lodash"));
const default_1 = __importStar(require("./default"));
const logger_1 = __importDefault(require("../../../logger"));
const utils_1 = require("../../utils");
const MAX_ACTION_DEPLOY_RETRY_ATTEMPTS = 60; // 60 * 2s => 2 min timeout
// With this schema, we can only validate property types but not valid properties on per type basis
exports.schema = {
    type: 'array',
    items: {
        type: 'object',
        required: ['name', 'supported_triggers', 'code'],
        additionalProperties: false,
        properties: {
            code: { type: 'string', default: '' },
            runtime: { type: 'string' },
            dependencies: {
                type: 'array',
                items: {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        name: { type: 'string' },
                        version: { type: 'string' },
                        registry_url: { type: 'string' },
                    },
                },
            },
            secrets: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        value: { type: 'string' },
                        updated_at: { type: 'string', format: 'date-time' },
                    },
                },
            },
            name: { type: 'string', default: '' },
            supported_triggers: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', default: '' },
                        version: { type: 'string' },
                        url: { type: 'string' },
                    },
                },
            },
            deployed: { type: 'boolean' },
            status: { type: 'string' },
        },
    },
};
function isActionsDisabled(err) {
    const errorBody = lodash_1.default.get(err, 'originalError.response.body') || {};
    return err.statusCode === 403 && errorBody.errorCode === 'feature_not_enabled';
}
function isMarketplaceAction(action) {
    return !!action.integration;
}
exports.isMarketplaceAction = isMarketplaceAction;
class ActionHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'actions', functions: {
                create: (action) => this.createAction(action),
                delete: (action) => this.deleteAction(action),
            }, stripUpdateFields: ['deployed', 'status'] }));
    }
    createAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            // Strip the deployed flag
            const addAction = Object.assign({}, action);
            delete addAction.deployed;
            delete addAction.status;
            const createdAction = yield this.client.actions.create(addAction);
            // Add the action id so we can deploy it later
            action.id = createdAction.id;
            return createdAction;
        });
    }
    deleteAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client.actions || typeof this.client.actions.delete !== 'function') {
                return [];
            }
            return this.client.actions.delete({ id: action.id, force: true });
        });
    }
    objString(action) {
        return super.objString({ id: action.id, name: action.name });
    }
    deployActions(actions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.pool
                .addEachTask({
                data: actions || [],
                generator: (action) => this.deployAction(action)
                    .then(() => {
                    logger_1.default.info(`Deployed [${this.type}]: ${this.objString(action)}`);
                })
                    .catch((err) => {
                    throw new Error(`Problem Deploying ${this.type} ${this.objString(action)}\n${err}`);
                }),
            })
                .promise();
        });
    }
    deployAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.client.actions.deploy({ id: action.id });
            }
            catch (err) {
                // Retry if pending build.
                if (err.message && err.message.includes("must be in the 'built' state")) {
                    if (!action.retry_count) {
                        logger_1.default.info(`[${this.type}]: Waiting for build to complete ${this.objString(action)}`);
                        action.retry_count = 1;
                    }
                    if (action.retry_count > MAX_ACTION_DEPLOY_RETRY_ATTEMPTS) {
                        throw err;
                    }
                    yield (0, utils_1.sleep)(2000);
                    action.retry_count += 1;
                    yield this.deployAction(action);
                }
                else {
                    throw err;
                }
            }
        });
    }
    actionChanges(action, found) {
        return __awaiter(this, void 0, void 0, function* () {
            const actionChanges = {};
            // if action is deployed, should compare against curren_version - calcDeployedVersionChanges method
            if (!action.deployed) {
                // name or secrets modifications are not supported yet
                if (action.code !== found.code) {
                    actionChanges.code = action.code;
                }
                if (action.runtime !== found.runtime) {
                    actionChanges.runtime = action.runtime;
                }
                if (!(0, utils_1.areArraysEquals)(action.dependencies, found.dependencies)) {
                    actionChanges.dependencies = action.dependencies;
                }
            }
            if (!(0, utils_1.areArraysEquals)(action.supported_triggers, found.supported_triggers)) {
                actionChanges.supported_triggers = action.supported_triggers;
            }
            return actionChanges;
        });
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.existing)
                return this.existing;
            if (!this.client.actions || typeof this.client.actions.getAll !== 'function') {
                return [];
            }
            // Actions API does not support include_totals param like the other paginate API's.
            // So we set it to false otherwise it will fail with "Additional properties not allowed: include_totals"
            try {
                const actions = yield this.client.actions.getAll({ paginate: true });
                this.existing = actions;
                return actions;
            }
            catch (err) {
                if (err.statusCode === 404 || err.statusCode === 501) {
                    return null;
                }
                if (err.statusCode === 500 && err.message === 'An internal server error occurred') {
                    throw new Error("Cannot process actions because the actions service is currently unavailable. Retrying may result in a successful operation. Alternatively, adding 'actions' to `AUTH0_EXCLUDED` configuration property will provide ability to skip until service is restored to actions service. This is not an issue with the Deploy CLI.");
                }
                if (isActionsDisabled(err)) {
                    logger_1.default.info('Skipping actions because it is not enabled.');
                    return null;
                }
                throw err;
            }
        });
    }
    processChanges(assets) {
        const _super = Object.create(null, {
            processChanges: { get: () => super.processChanges }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { actions } = assets;
            // Do nothing if not set
            if (!actions)
                return;
            const changes = yield this.calcChanges(assets);
            //Management of marketplace actions not currently supported, see ESD-23225.
            const changesWithMarketplaceActionsFiltered = (() => {
                return Object.assign(Object.assign({}, changes), { del: changes.del.filter((action) => !isMarketplaceAction(action)) });
            })();
            yield _super.processChanges.call(this, assets, changesWithMarketplaceActionsFiltered);
            const postProcessedActions = yield (() => __awaiter(this, void 0, void 0, function* () {
                this.existing = null; //Clear the cache
                const actions = yield this.getType();
                return actions;
            }))();
            // Deploy actions
            const deployActions = [
                ...changes.create
                    .filter((action) => action.deployed)
                    .map((actionWithoutId) => {
                    var _a;
                    // Add IDs to just-created actions
                    const actionId = (_a = postProcessedActions === null || postProcessedActions === void 0 ? void 0 : postProcessedActions.find((postProcessedAction) => {
                        return postProcessedAction.name === actionWithoutId.name;
                    })) === null || _a === void 0 ? void 0 : _a.id;
                    const actionWithId = Object.assign(Object.assign({}, actionWithoutId), { id: actionId });
                    return actionWithId;
                })
                    .filter((action) => !!action.id),
                ...changes.update.filter((action) => action.deployed),
            ];
            yield this.deployActions(deployActions);
        });
    }
}
__decorate([
    (0, default_1.order)('60')
], ActionHandler.prototype, "processChanges", null);
exports.default = ActionHandler;
//# sourceMappingURL=actions.js.map