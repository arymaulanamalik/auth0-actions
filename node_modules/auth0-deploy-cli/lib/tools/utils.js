"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDeprecatedError = exports.sleep = exports.detectInsufficientScopeError = exports.stripObfuscatedFieldsFromPayload = exports.obfuscateSensitiveValues = exports.areArraysEquals = exports.filterExcluded = exports.duplicateItems = exports.getEnabledClients = exports.stripFields = exports.convertJsonToString = exports.flatten = exports.loadFileAndReplaceKeywords = exports.convertClientNamesToIds = exports.convertClientNameToId = exports.wrapArrayReplaceMarkersInQuotes = exports.keywordReplace = exports.keywordStringReplace = exports.keywordArrayReplace = exports.keywordReplaceStringRegExp = exports.keywordReplaceArrayRegExp = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importStar(require("fs"));
const dot_prop_1 = __importDefault(require("dot-prop"));
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("../logger"));
const constants_1 = __importDefault(require("./constants"));
const keywordReplaceArrayRegExp = (key) => {
    const pattern = `@@${key}@@`;
    //YAML format supports both single and double quotes for strings
    const patternWithSingleQuotes = `'${pattern}'`;
    const patternWithDoubleQuotes = `"${pattern}"`;
    return new RegExp(`${patternWithSingleQuotes}|${patternWithDoubleQuotes}|${pattern}`, 'g');
};
exports.keywordReplaceArrayRegExp = keywordReplaceArrayRegExp;
const keywordReplaceStringRegExp = (key) => {
    return new RegExp(`##${key}##`, 'g');
};
exports.keywordReplaceStringRegExp = keywordReplaceStringRegExp;
function keywordArrayReplace(input, mappings) {
    Object.keys(mappings).forEach(function (key) {
        // Matching against two sets of patterns because a developer may provide their array replacement keyword with or without wrapping quotes. It is not obvious to the developer which to do depending if they're operating in YAML or JSON.
        const regex = (0, exports.keywordReplaceArrayRegExp)(key);
        input = input.replace(regex, JSON.stringify(mappings[key]));
    });
    return input;
}
exports.keywordArrayReplace = keywordArrayReplace;
function keywordStringReplace(input, mappings) {
    Object.keys(mappings).forEach(function (key) {
        const regex = (0, exports.keywordReplaceStringRegExp)(key);
        // @ts-ignore TODO: come back and distinguish strings vs array replacement.
        input = input.replace(regex, mappings[key]);
    });
    return input;
}
exports.keywordStringReplace = keywordStringReplace;
function keywordReplace(input, mappings) {
    // Replace keywords with mappings within input.
    if (mappings && Object.keys(mappings).length > 0) {
        input = keywordArrayReplace(input, mappings);
        input = keywordStringReplace(input, mappings);
    }
    return input;
}
exports.keywordReplace = keywordReplace;
// wrapArrayReplaceMarkersInQuotes will wrap array replacement markers in quotes.
// This is necessary for YAML format in the context of keyword replacement
// to preserve the keyword markers while also maintaining valid YAML syntax.
function wrapArrayReplaceMarkersInQuotes(body, mappings) {
    let newBody = body;
    Object.keys(mappings).forEach((keyword) => {
        newBody = newBody.replace(new RegExp('(?<![\'"])@@' + keyword + '@@(?![\'"])', 'g'), `"@@${keyword}@@"`);
    });
    return newBody;
}
exports.wrapArrayReplaceMarkersInQuotes = wrapArrayReplaceMarkersInQuotes;
function convertClientNameToId(name, clients) {
    const found = clients.find((c) => c.name === name);
    return (found && found.client_id) || name;
}
exports.convertClientNameToId = convertClientNameToId;
function convertClientNamesToIds(names, clients) {
    const resolvedNames = names.map((name) => ({ name, resolved: false }));
    const result = clients.reduce((acc, client) => {
        if (names.includes(client.name)) {
            const index = resolvedNames.findIndex((item) => item.name === client.name);
            resolvedNames[index].resolved = true;
            return [...acc, client.client_id];
        }
        return [...acc];
    }, []);
    const unresolved = resolvedNames.filter((item) => !item.resolved).map((item) => item.name);
    // @ts-ignore TODO: come back and refactor to use map instead of reduce.
    return [...unresolved, ...result];
}
exports.convertClientNamesToIds = convertClientNamesToIds;
function loadFileAndReplaceKeywords(file, { mappings, disableKeywordReplacement = false, }) {
    // Load file and replace keyword mappings
    const f = path_1.default.resolve(file);
    try {
        fs_1.default.accessSync(f, fs_1.constants.F_OK);
        if (mappings && !disableKeywordReplacement) {
            return keywordReplace(fs_1.default.readFileSync(f, 'utf8'), mappings);
        }
        return fs_1.default.readFileSync(f, 'utf8');
    }
    catch (error) {
        throw new Error(`Unable to load file ${f} due to ${error}`);
    }
}
exports.loadFileAndReplaceKeywords = loadFileAndReplaceKeywords;
function flatten(list) {
    // Flatten an multiple arrays to single array
    return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
}
exports.flatten = flatten;
function convertJsonToString(obj, spacing = 0) {
    return JSON.stringify(obj, null, spacing);
}
exports.convertJsonToString = convertJsonToString;
function stripFields(obj, fields) {
    // Strip object fields supporting dot notation (ie: a.deep.field)
    const stripped = [];
    const newObj = Object.assign({}, obj);
    fields.forEach((f) => {
        if (dot_prop_1.default.get(newObj, f) !== undefined) {
            dot_prop_1.default.delete(newObj, f);
            stripped.push(f);
        }
    });
    if (stripped) {
        const name = ['id', 'client_id', 'template', 'name'].reduce((n, k) => newObj[k] || n, '');
        logger_1.default.debug(`Stripping "${name}" read-only fields ${JSON.stringify(stripped)}`);
    }
    return newObj;
}
exports.stripFields = stripFields;
function getEnabledClients(assets, connection, existing, clients) {
    // Convert enabled_clients by name to the id
    if (connection.enabled_clients === undefined)
        return undefined; // If no enabled clients passed in, explicitly ignore from management, preventing unintentional disabling of connection.
    const excludedClientsByNames = (assets.exclude && assets.exclude.clients) || [];
    const excludedClients = convertClientNamesToIds(excludedClientsByNames, clients);
    const enabledClients = [
        ...convertClientNamesToIds(connection.enabled_clients || [], clients).filter((item) => ![...excludedClientsByNames, ...excludedClients].includes(item)),
    ];
    // If client is excluded and in the existing connection this client is enabled, it should keep enabled
    // If client is excluded and in the existing connection this client is disabled, it should keep disabled
    existing.forEach((conn) => {
        if (conn.name === connection.name) {
            excludedClients.forEach((excludedClient) => {
                if (conn.enabled_clients.includes(excludedClient)) {
                    enabledClients.push(excludedClient);
                }
            });
        }
    });
    return enabledClients;
}
exports.getEnabledClients = getEnabledClients;
function duplicateItems(arr, key) {
    // Find duplicates objects within array that have the same key value
    const duplicates = arr.reduce((accum, obj) => {
        const keyValue = obj[key];
        if (keyValue) {
            if (!(keyValue in accum))
                accum[keyValue] = [];
            accum[keyValue].push(obj);
        }
        return accum;
    }, {});
    return Object.values(duplicates).filter((g) => g.length > 1);
}
exports.duplicateItems = duplicateItems;
function filterExcluded(changes, exclude) {
    const { del, update, create, conflicts } = changes;
    if (!exclude.length) {
        return changes;
    }
    const filter = (list) => list.filter((item) => !exclude.includes(item.name));
    return {
        del: filter(del),
        update: filter(update),
        create: filter(create),
        conflicts: filter(conflicts),
    };
}
exports.filterExcluded = filterExcluded;
function areArraysEquals(x, y) {
    return lodash_1.default.isEqual(x && x.sort(), y && y.sort());
}
exports.areArraysEquals = areArraysEquals;
const obfuscateSensitiveValues = (data, sensitiveFieldsToObfuscate) => {
    if (data === null)
        return data;
    if (Array.isArray(data)) {
        return data.map((asset) => (0, exports.obfuscateSensitiveValues)(asset, sensitiveFieldsToObfuscate));
    }
    const newAsset = Object.assign({}, data);
    sensitiveFieldsToObfuscate.forEach((sensitiveField) => {
        if (dot_prop_1.default.get(newAsset, sensitiveField) !== undefined) {
            dot_prop_1.default.set(newAsset, sensitiveField, constants_1.default.OBFUSCATED_SECRET_VALUE);
        }
    });
    return newAsset;
};
exports.obfuscateSensitiveValues = obfuscateSensitiveValues;
// The reverse of `obfuscateSensitiveValues()`, preventing an obfuscated value from being passed to the API
const stripObfuscatedFieldsFromPayload = (data, obfuscatedFields) => {
    if (data === null)
        return data;
    if (Array.isArray(data)) {
        return data.map((asset) => (0, exports.stripObfuscatedFieldsFromPayload)(asset, obfuscatedFields));
    }
    const newAsset = Object.assign({}, data);
    obfuscatedFields.forEach((sensitiveField) => {
        const obfuscatedFieldValue = dot_prop_1.default.get(newAsset, sensitiveField);
        if (obfuscatedFieldValue === constants_1.default.OBFUSCATED_SECRET_VALUE) {
            dot_prop_1.default.delete(newAsset, sensitiveField);
        }
    });
    return newAsset;
};
exports.stripObfuscatedFieldsFromPayload = stripObfuscatedFieldsFromPayload;
const detectInsufficientScopeError = (fn) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const data = yield fn();
        return {
            hadSufficientScopes: true,
            data,
            requiredScopes: [],
        };
    }
    catch (err) {
        if (err.statusCode === 403 && err.message.includes('Insufficient scope')) {
            const requiredScopes = (_b = (_a = err.message) === null || _a === void 0 ? void 0 : _a.split('Insufficient scope, expected any of: ')) === null || _b === void 0 ? void 0 : _b.slice(1);
            return {
                hadSufficientScopes: false,
                requiredScopes,
                data: null,
            };
        }
        throw err;
    }
});
exports.detectInsufficientScopeError = detectInsufficientScopeError;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
const isDeprecatedError = (err) => {
    var _a;
    if (!err)
        return false;
    return !!(err.statusCode === 403 || ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('deprecated feature')));
};
exports.isDeprecatedError = isDeprecatedError;
//# sourceMappingURL=utils.js.map